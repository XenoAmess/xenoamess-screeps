{"ok":1,"branch":"using","modules":{"methods":"var methods = {\n    closest : function(creep,targets) {\n        var mina = 1<<30;\n        var mini = undefined;\n        for(var name in targets){\n            var newa = creep.pos.getRangeTo(targets[name].pos);\n            if(newa>=0 && newa < mina){\n                mina = newa;\n                mini = name;\n            }\n        }\n        return mini;\n    },\n    lessHits : function(targets){\n        var mina = 1<<30;\n        var mini = undefined;\n        for(var name in targets){\n            var newa = targets[name].hits;\n            if(newa < mina){\n                mina = newa;\n                mini = name;\n            }\n        }\n        return mini;\n    }\n}\nmodule.exports = methods;","main":"var roles = [];\nvar roleHarvester = require('role.harvester');\nroles['harvester'] = roleHarvester;\n\nvar roleUpgrader = require('role.upgrader');\nroles['upgrader'] = roleUpgrader;\n\nvar roleFighter = require('role.fighter');\nroles['fighter'] = roleFighter;\n\nvar roleBuilder = require('role.builder');\nroles['builder'] = roleBuilder;\n\nvar roleHealer = require('role.healer');\nroles['healer'] = roleHealer;\n\nvar superRoleBaseTower = require('superRole.baseTower');\n\ncnt = [];\n\nMIN_HARVESTER = 4;\n\nroomNeedingEnergyCreepsCnt = [];\nroomNeedingHealCreeps = [];\n\n\nroomNeedingChargeTowers = [];\nroomNeedingRepairStructures = [];\nroomNeedingBuildConstructionSite = [];\n\n\nMemory.WAR_MODE = 0;\n\n\nenemiesInMyBase = new Array();\nENEMY_IN_MY_BASE = 0\n\n\nTOWER_NEED_CHARGE_NUM = 0.7;\nSTRUCTURE_NEED_REPAIR_NUM = 0.8;\n\nRAMPART_HP = 10000;\n\ndefendBase = function(){\n    if(!Memory.structures){\n        Memory.structures = {};\n    }\n    if(\n        (\n            enemiesInMyBase = Game.spawns[\"Spawn1\"].room.find(FIND_CREEPS, {\n                filter: (object) => {\n                    return (!object.my);\n                }\n            })\n        ).length > 0) {\n        Memory.WAR_MODE = 1;\n        ENEMY_IN_MY_BASE = 1;\n    }\n    if(Game.spawns[\"Spawn1\"].hits < Game.spawns[\"Spawn1\"].hitsMax/2){\n        Game.spawns[\"Spawn1\"].room.controller.activateSafeMode();\n    }\n} \n\ninitLists = function(){\n    roomNeedingEnergyCreepsCnt = [];\n    for(var name in Game.creeps){\n        if(!roomNeedingEnergyCreepsCnt[Game.creeps[name].room]){\n            roomNeedingEnergyCreepsCnt[Game.creeps[name].room] = [];\n        }\n        if(Game.creeps[name].carry.energy < Game.creeps[name].carryCapacity){\n            if(!roomNeedingEnergyCreepsCnt[Game.creeps[name].room][Game.creeps[name].memory.role]){\n                roomNeedingEnergyCreepsCnt[Game.creeps[name].room][Game.creeps[name].memory.role] = 0;\n            }\n            roomNeedingEnergyCreepsCnt[Game.creeps[name].room][Game.creeps[name].memory.role]++;\n        }\n    }\n    \n    roomNeedingHealCreeps = [];\n    for(var name in Game.creeps){\n        if(!roomNeedingHealCreeps[Game.creeps[name].room]){\n            roomNeedingHealCreeps[Game.creeps[name].room] = new Array();\n        }\n        if(Game.creeps[name].hits < Game.creeps[name].hitsMax){\n            roomNeedingHealCreeps[Game.creeps[name].room].push(Game.creeps[name]);\n        }\n    }\n    \n    \n    roomNeedingChargeTowers = [];\n    for(var name in Game.structures){\n        if(Game.structures[name].structureType == STRUCTURE_TOWER && Game.structures[name].energy < Game.structures[name].energyCapacity * TOWER_NEED_CHARGE_NUM){\n            if(!roomNeedingChargeTowers[Game.structures[name].room]){\n                roomNeedingChargeTowers[Game.structures[name].room] = new Array();\n            }\n            roomNeedingChargeTowers[Game.structures[name].room].push(Game.structures[name]);\n        }\n    }\n    \n    roomNeedingRepairStructures = [];\n    for(var name in Game.structures){\n        if((Game.structures[name].structureType == STRUCTURE_RAMPART || Game.structures[name].structureType == STRUCTURE_WALL) && Game.structures[name].hits >= RAMPART_HP){\n            continue;\n        }\n        if(Game.structures[name].hits < Game.structures[name].hitsMax * STRUCTURE_NEED_REPAIR_NUM){\n            if(!roomNeedingRepairStructures[Game.structures[name].room]){\n                roomNeedingRepairStructures[Game.structures[name].room] = new Array();\n            }\n            roomNeedingRepairStructures[Game.structures[name].room].push(Game.structures[name]);\n        }\n    }\n    \n    roomNeedingBuildConstructionSite = [];\n    for(var name in Game.constructionSites){\n        if(!roomNeedingBuildConstructionSite[Game.constructionSites[name].room]){\n            roomNeedingBuildConstructionSite[Game.constructionSites[name].room] = new Array();\n        }\n        roomNeedingBuildConstructionSite[Game.constructionSites[name].room].push(Game.constructionSites[name]);\n    }\n};\n\nbuildCreeps = function(){\n        for(var name in Memory.creeps) {\n        if(!Game.creeps[name]) {\n            delete Memory.creeps[name];\n            // console.log('Clearing non-existing creep memory:', name);\n        }\n    }\n    \n    for(var name in roles){\n        cnt[name] = 0;\n    }\n    for(var name in Game.creeps){\n        cnt[Game.creeps[name].memory.role]++; \n    }\n    \n\n    console.log(\"now I have:\");\n    for(var name in cnt){\n        console.log( name + \":\" + cnt[name]);\n    }\n    console.log(new Date());\n    \n    if(cnt[\"harvester\"] < MIN_HARVESTER){\n        Game.spawns['Spawn1'].createCreep([WORK,WORK,WORK,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE], 'harvester' + parseInt(Math.random() * 8999 + 1000), {role: 'harvester'});\n    }else{\n        //if(Memory.WAR_MODE && cnt[\"healer\"] < cnt[\"fighter\"]/3){\n        //    Game.spawns['Spawn1'].createCreep([TOUGH,TOUGH,TOUGH,MOVE,MOVE,MOVE,MOVE,HEAL,HEAL], 'healer' + parseInt(Math.random() * 8999 + 1000), {role: 'healer'});\n        //} else \n        if(Memory.WAR_MODE && cnt[\"fighter\"] < cnt[\"harvester\"]){\n            Game.spawns['Spawn1'].createCreep([TOUGH,TOUGH,TOUGH,TOUGH,TOUGH,TOUGH,ATTACK,MOVE,ATTACK,MOVE,ATTACK,MOVE,ATTACK,ATTACK,MOVE,MOVE], 'fighter' + parseInt(Math.random() * 8999 + 1000), {role: 'fighter'});\n            //Game.spawns['Spawn1'].createCreep([ATTACK,ATTACK,ATTACK,MOVE], 'fighter' + parseInt(Math.random() * 899 + 100), {role: 'fighter'});\n        } else if(cnt[\"upgrader\"] < 10 && cnt[\"upgrader\"] < cnt[\"harvester\"]){\n            Game.spawns['Spawn1'].createCreep([WORK,WORK,WORK,CARRY,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE],'upgrader' + parseInt(Math.random() * 8999 + 1000), {role: 'upgrader'});\n            //Game.spawns['Spawn1'].createCreep([WORK,WORK,CARRY,MOVE],'upgrader' + parseInt(Math.random() * 899 + 100), {role: 'upgrader'});\n        } else if(cnt[\"builder\"] < 5 && cnt[\"builder\"] < cnt[\"harvester\"] / 2 - 1){\n            Game.spawns['Spawn1'].createCreep([WORK,WORK,WORK,CARRY,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE], 'builder' + parseInt(Math.random() * 8999 + 1000), {role: 'builder'});\n            //Game.spawns['Spawn1'].createCreep([WORK,WORK,CARRY,MOVE], 'builder' + parseInt(Math.random() * 899 + 100), {role: 'builder'});\n        }else{\n            Game.spawns['Spawn1'].createCreep([WORK,WORK,WORK,CARRY,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE], 'harvester' + parseInt(Math.random() * 8999 + 1000), {role: 'harvester'});\n            //Game.spawns['Spawn1'].createCreep([WORK,WORK,CARRY,MOVE], 'harvester' + parseInt(Math.random() * 899 + 100), {role: 'harvester'});\n        }\n    }\n    \n    if(Game.spawns['Spawn1'].spawning) { \n        var spawningCreep = Game.creeps[Game.spawns['Spawn1'].spawning.name];\n        Game.spawns['Spawn1'].room.visual.text(\n            'ðŸ› ï¸' + spawningCreep.memory.role,\n            Game.spawns['Spawn1'].pos.x + 1, \n            Game.spawns['Spawn1'].pos.y, \n            {align: 'left', opacity: 0.8});\n    }\n};\n\nrunCreeps = function(){\n\n        \n    for(var name in Game.creeps) {\n        var creep = Game.creeps[name];\n        roles[creep.memory.role].run(creep);\n    }\n    \n    for(var name in Game.structures){\n        var structure = Game.structures[name];\n        if(structure.structureType == STRUCTURE_TOWER){\n            if(structure.hits < structure.hitsMax / 2){\n                Game.spawns[\"Spawn1\"].room.controller.activateSafeMode();\n            }\n            superRoleBaseTower.run(structure);\n        }\n        //structure.memory.role;\n    }\n};\n\n//-------------------------------------------------\n//-------------------------------------------------\n//-------------------------------------------------\n//-------------------------------------------------\n//-------------------------------------------------\n//-------------------------------------------------\n//-------------------------------------------------\n//-------------------------------------------------\n//-------------------------------------------------\n//-------------------------------------------------\n\n\nmodule.exports.loop = function () {\n    defendBase()\n    initLists();\n    buildCreeps();\n    runCreeps();\n}","move.harvest":"var methods = require(\"methods\");\nvar moveHarvest = {\n    run : function(creep) {\n        //console.log(creep.memory.lastRepairTarget);\n        //console.log(nowTarget);\n        var nowTarget = Game.getObjectById(creep.memory.lastHarvestTarget);\n        \n        if(creep.memory.lastHarvestTarget && nowTarget){\n\t        if(nowTarget.room == creep.room && nowTarget.energy > 0){\n\t            creep.moveTo(nowTarget, {visualizePathStyle: {stroke: '#ffffff'}});\n                creep.harvest(nowTarget);\n                return;\n\t        }\n        }\n        creep.memory.lastHarvestTarget = null;\n        \n        var targets = creep.room.find(FIND_SOURCES , {\n            filter: (object) => {\n                return (object.energy > 0);\n            }\n        });\n        if(targets.length){\n            var mini = methods.closest(creep,targets);\n            creep.memory.lastHarvestTarget = targets[mini].id;\n            if(creep.harvest(targets[mini]) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(targets[mini], {visualizePathStyle: {stroke: '#ffaa00'}});\n            }\n        }\n    }\n}\nmodule.exports = moveHarvest;","move.repairAndBuild":"var methods = require(\"methods\");\nvar moveRepairAndBuild = {\n    run : function(creep){\n        var nowTarget;\n        nowTarget = Game.getObjectById(creep.memory.lastRepairTarget);\n        \n        //console.log(creep.memory.lastRepairTarget);\n        //console.log(nowTarget);\n        \n        if(creep.memory.lastRepairTarget && nowTarget){\n            if(nowTarget.room == creep.room && nowTarget.hits < nowTarget.hitsMax && (!(nowTarget.structureType == STRUCTURE_RAMPART && nowTarget.hits >= RAMPART_HP))){\n                creep.moveTo(nowTarget, {visualizePathStyle: {stroke: '#ffffff'}});\n                creep.repair(nowTarget);\n                return;\n            }\n        }\n        creep.memory.lastRepairTarget = null;\n        \n        nowTarget = Game.getObjectById(creep.memory.lastBuildTarget);\n        \n        if(creep.memory.lastBuildTarget && nowTarget){\n            if(nowTarget.room == creep.room && creep.memory.lastBuildTarget && nowTarget.progress < nowTarget.progressTotal){\n                creep.moveTo(nowTarget, {visualizePathStyle: {stroke: '#ffffff'}});\n                creep.build(nowTarget);\n                return;\n            }\n        }\n        creep.memory.lastBuildTarget = null;\n        \n        var targets = roomNeedingRepairStructures[creep.room];\n        \n        if(targets && targets.length) {\n            var mini = methods.closest(creep,targets);\n            \n            creep.memory.lastRepairTarget = targets[mini].id;\n            creep.moveTo(targets[mini], {visualizePathStyle: {stroke: '#ffffff'}});\n            creep.repair(targets[mini]);\n        }else{\n            var targets = roomNeedingBuildConstructionSite[creep.room];\n            if(targets && targets.length) {\n                var mini = methods.closest(creep,targets);\n                creep.memory.lastBuildTarget = targets[mini].id;\n                creep.moveTo(targets[mini], {visualizePathStyle: {stroke: '#ffffff'}});\n                creep.build(targets[mini]);\n            }else{\n                creep.moveTo(Game.spawns[\"Spawn1\"], {visualizePathStyle: {stroke: '#ffaa00'}});\n            }\n        }\n    }\n}\nmodule.exports = moveRepairAndBuild;","move.transportEnergy":"var methods = require(\"methods\");\nvar moveTransportEnergy = {\n    run : function(creep) {\n        //console.log(creep.memory.lastRepairTarget);\n        //console.log(nowTarget);\n        var nowTarget = Game.getObjectById(creep.memory.lastTransportEnergyTarget);\n        \n        if(creep.memory.lastTransportEnergyTarget && nowTarget){\n\t        if(nowTarget.room == creep.room && nowTarget.energy < nowTarget.energyCapacity){\n\t            creep.moveTo(nowTarget, {visualizePathStyle: {stroke: '#ffffff'}});\n                creep.transfer(nowTarget, RESOURCE_ENERGY);\n                return;\n\t        }else{\n\t            creep.memory.lastTransportEnergyTarget = null;\n\t        }\n        }\n        \n        var targets = creep.room.find(FIND_STRUCTURES, {\n                filter: (structure) => {\n                    return (structure.structureType == STRUCTURE_EXTENSION || structure.structureType == STRUCTURE_SPAWN || structure.structureType == STRUCTURE_STORAGE) &&\n                        (structure.energy < structure.energyCapacity);\n                }\n        });\n        if(targets.length > 0) {\n            var mini = methods.closest(creep,targets);\n            \n            creep.memory.lastTransportEnergyTarget = targets[mini].id;\n            if(creep.transfer(targets[mini], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(targets[mini], {visualizePathStyle: {stroke: '#ffffff'}});\n            }\n        }else{\n            creep.moveTo(Game.spawns[\"Spawn1\"], {visualizePathStyle: {stroke: '#ffffff'}});\n        }\n    }\n}\nmodule.exports = moveTransportEnergy;","role.upgrader":"var methods = require(\"methods\");\nvar moveHarvest = require(\"move.harvest\");\nvar roleUpgrader = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n        if(creep.hits < creep.hitsMax && creep.room != Game.spawns[\"Spawn1\"].room){\n            creep.moveTo(Game.spawns[\"Spawn1\"]);\n            return;\n        }\n        if(creep.room.controller.owner != undefined && !creep.room.controller.my){\n            creep.moveTo(Game.spawns[\"Spawn1\"]);\n            return;\n        }\n        \n        \n        \n        if(cnt[\"harvester\"] < MIN_HARVESTER){\n            creep.memory.role = \"harvester\";\n            cnt[\"harvester\"]++;\n            return;\n        }\n        \n        if(creep.memory.upgrading && creep.carry.energy == 0) {\n            creep.memory.upgrading = false;\n            creep.say('ðŸ”„ harvest');\n\t    }\n\t    if(!creep.memory.upgrading && creep.carry.energy == creep.carryCapacity) {\n\t        creep.memory.upgrading = true;\n\t        creep.say('âš¡ upgrade');\n\t    }\n\n\t    if(creep.memory.upgrading) {\n\t        if(!creep.room.controller.my){\n\t            creep.moveTo(Game.spawns['Spawn1'], {visualizePathStyle: {stroke: '#ffffff'}});\n\t        }else{\n\t            creep.moveTo(creep.room.controller, {visualizePathStyle: {stroke: '#ffffff'}});\n\t            var res = creep.upgradeController(creep.room.controller);\n                if(res == ERR_NOT_IN_RANGE) {\n                    // creep.moveTo(creep.room.controller, {visualizePathStyle: {stroke: '#ffffff'}});\n                }\n\t        }\n        } else {\n            moveHarvest.run(creep);\n        }\n\t}\n};\n\nmodule.exports = roleUpgrader;","role.fighter":"var methods = require(\"methods\");\nvar roleFighter = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n        var targets;\n        targets = creep.room.find(FIND_CREEPS, {\n            filter: (creep) => {\n               return (!creep.my);\n            }\n        });\n        \n        if(targets.length > 0){\n            var mini = methods.closest(creep,targets);\n            var res;\n            res = creep.attack(targets[mini]);\n            if(res == OK){\n                return;\n            }else if(res == ERR_NOT_IN_RANGE){\n                res = creep.moveTo(targets[mini], {visualizePathStyle: {stroke: '#ffffff'}});\n                if(res != ERR_NO_PATH){\n                    return;\n                }\n            }\n        }\n        \n        targets = creep.room.find(FIND_STRUCTURES, {\n            filter: (structure) => {\n                return (!structure.my && structure.owner != undefined && structure.structureType != STRUCTURE_ROAD && structure.structureType != STRUCTURE_WALL && structure.structureType != STRUCTURE_CONTROLLER);\n            }\n        });\n        //console.log(targets.length);\n        if(targets.length > 0){\n            //console.log(\"I'm in.\");\n            var mini = methods.closest(creep,targets);\n            var res = creep.attack(targets[mini]);\n            if(res == OK)\n                return;\n            res = creep.moveTo(targets[mini], {visualizePathStyle: {stroke: '#ffffff'}});\n            //console.log(\"res : \"+res);\n            //console.log(\"ERR_NO_PATH : \"+ERR_NO_PATH);\n            //console.log(targets[mini]);\n            targets = creep.room.find(FIND_STRUCTURES, {\n                filter: (structure) => {\n                    return (!structure.my && (structure.structureType == STRUCTURE_WALL || structure.structureType == STRUCTURE_RAMPART) && structure.hits);\n                }\n            });\n            var mini = methods.closest(creep,targets);\n            creep.attack(targets[mini]);\n            creep.moveTo(targets[mini], {visualizePathStyle: {stroke: '#ffffff'}})\n            \n        }else{\n            creep.moveTo(Game.flags[\"FlagAttack\"],{visualizePathStyle: {stroke: '#ffffff'}});\n        }\n    }\n};\n\nmodule.exports = roleFighter;","role.builder":"var methods = require(\"methods\");\nvar moveHarvest = require(\"move.harvest\");\nvar moveRepairAndBuild = require(\"move.repairAndBuild\");\nvar moveChargeTower = require(\"move.chargeTower\");\n\nvar roleBuilder = {\n    /** @param {Creep} creep **/\n    run: function(creep) {\n        if(creep.hits < creep.hitsMax && creep.room != Game.spawns[\"Spawn1\"].room){\n            creep.moveTo(Game.spawns[\"Spawn1\"]);\n            return;\n        }\n        if(creep.room.controller.owner != undefined && !creep.room.controller.my){\n            creep.moveTo(Game.spawns[\"Spawn1\"]);\n            return;\n        }\n        \n        \n        if(cnt[\"harvester\"] < MIN_HARVESTER){\n            creep.memory.role = \"harvester\";\n            cnt[\"harvester\"]++;\n            return;\n        }\n        \n\t    if(creep.memory.building && creep.carry.energy == 0) {\n            creep.memory.building = false;\n            creep.say('ðŸ”„ harvest');\n\t    }else if(!creep.memory.building && creep.carry.energy == creep.carryCapacity) {\n\t        creep.memory.building = true;\n\t        creep.say('ðŸš§ build');\n\t    }\n    \n        \n        \n\t    if(creep.memory.building) {\n\t        if(moveChargeTower.run(creep)){\n\t            return;\n\t        }\n            moveRepairAndBuild.run(creep);\n\t    } else {\n\t        var builderCnt = roomNeedingEnergyCreepsCnt[creep.room][creep.memory.role];\n            if((creep.room == Game.spawns[\"Spawn1\"].room && builderCnt > 1) || builderCnt > 2){\n                creep.moveTo(Game.flags[\"FlagResources\"], {visualizePathStyle: {stroke: '#ffaa00'}});\n            }else{\n                moveHarvest.run(creep);\n            }\n\t    }\n\t}\n};\n\nmodule.exports = roleBuilder;","role.harvester":"var methods = require(\"methods\");\nvar moveHarvest = require(\"move.harvest\");\nvar moveTransportEnergy = require(\"move.transportEnergy\");\n\nvar roleHarvester = {\n    \n    /** @param {Creep} creep **/\n    run: function(creep) {\n        if(creep.hits < creep.hitsMax && creep.room != Game.spawns[\"Spawn1\"].room){\n            creep.moveTo(Game.spawns[\"Spawn1\"]);\n            return;\n        }\n        if(creep.room.controller.owner != undefined && !creep.room.controller.my){\n            creep.moveTo(Game.spawns[\"Spawn1\"]);\n            return;\n        }\n        \n        \n        \n        if(!creep.memory.harvesting && creep.carry.energy == 0) {\n            creep.memory.harvesting = true;\n            creep.say('ðŸ”„ harvest');\n\t    }\n\t    if(creep.memory.harvesting && creep.carry.energy == creep.carryCapacity) {\n\t        creep.memory.harvesting = false;\n\t        creep.say('ðŸš§ transport');\n\t    }\n        \n        if(!creep.memory.harvesting) {\n            moveTransportEnergy.run(creep);\n        } else {\n            var harvesterCnt = roomNeedingEnergyCreepsCnt[creep.room][creep.memory.role];\n            if((creep.room == Game.spawns[\"Spawn1\"].room && harvesterCnt > 2)  || harvesterCnt > 3){\n                creep.moveTo(Game.flags[\"FlagResources\"], {visualizePathStyle: {stroke: '#ffaa00'}});\n            }else{\n                moveHarvest.run(creep);\n            }\n        }\n        \n\t}\n};\n\nmodule.exports = roleHarvester;","move.chargeTower":"var methods = require(\"methods\");\nvar moveChargeTower = {\n    run : function(creep){\n        if(roomNeedingChargeTowers[creep.room] && roomNeedingChargeTowers[creep.room].length > 0){\n            var mini = methods.closest(creep,roomNeedingChargeTowers[creep.room]);\n            creep.moveTo(roomNeedingChargeTowers[creep.room][mini]);\n            creep.transfer(roomNeedingChargeTowers[creep.room][mini],RESOURCE_ENERGY);\n            return true;\n        }\n        return false;\n    }\n}\nmodule.exports = moveChargeTower;","superRole.baseTower":"var methods = require(\"methods\");\nvar superRoleBaseTower = {\n    run : function (tower){\n        //console.log(tower.id);\n        if(ENEMY_IN_MY_BASE){\n            tower.attack(enemiesInMyBase[methods.lessHits(enemiesInMyBase)]);\n        }else if(roomNeedingHealCreeps[tower.room] && roomNeedingHealCreeps[tower.room].length){\n            tower.heal(roomNeedingHealCreeps[tower.room][methods.lessHits(roomNeedingHealCreeps[tower.room])]);\n        }else if(roomNeedingRepairStructures[tower.room] && roomNeedingRepairStructures[tower.room].length){\n            tower.repair(roomNeedingRepairStructures[tower.room][methods.lessHits(roomNeedingRepairStructures[tower.room])]);\n        }\n    }\n}\nmodule.exports = superRoleBaseTower;","role.healer":"var methods = require(\"methods\");\nvar roleHealer = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n        var targets = roomNeedingHealCreeps[creep.room];\n        if(targets.length > 0){\n            var mini = methods.closest(creep,targets);\n            var res;\n            res = creep.heal(targets[mini]);\n            if(res == OK){\n            }else if(res == ERR_NOT_IN_RANGE){\n                creep.moveTo(targets[mini], {visualizePathStyle: {stroke: '#ffffff'}});\n            }\n        }else{\n            creep.moveTo(Game.flags[\"FlagAttack\"],{visualizePathStyle: {stroke: '#ffffff'}});\n        }\n    }\n};\n\nmodule.exports = roleHealer;"}}